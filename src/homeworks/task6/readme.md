## Задача 1. 
Чтобы разблокировать телефон, пользователь может выбрать один из способов:
- Без пароля
- С пин-кодом (4-значное число)
- По отпечатку пальца (кодируется строкой)
- По распознаванию лица (кодируется строкой)

Программист написал класс Unlocker, в котором хранятся поля от всех способов сразу:

    class Unlocker {
        private int mode; // режим
        private int pin; // на случай пин-кода
        private String fingerprint; // на случай отпечатка пальца
        private String faceID; // на случай лица
    }
Здесь нарушен принцип SRP: класс имеет несколько незаивисимых причин меняться.
Напишите решение, которое будет соответствовать SRP и OCP (мы хотим в будущем добавлять новые способы разблокировки).

## **_Решение:_**

- Разбили класс Unlocker на несколько классов, которые реализуют общий интерфейс PhoneUnlocker.
- У каждого класса своя реализация метода unlock()
- Создали класс MyPhone, добавили поле типа PhoneUnlocker, теперь телефон может быть разблокирован любым способом, который мы укажем в конструкторе.



## Задача 2. 
Есть два самодельных класса коллекций:

ImmutableList<T> — коллекция, которая никогда ни при каких обстоятельствах не меняется. Методы:
    
    getSize ()
    get (int i)

MutableList<T> — коллекция, которая допускает изменения. Методы:

    getSize ()
    get (int i)
    set (int i, T newValue)
    add (T newValue)
    remove (T value)

Реализуйте такую схему наследования между двумя этими классами, которая будет соответствовать принципу подстановки Лисков.

## **_Решение:_**
- Создали интерфейс CustomList, в котором будут два общих, для классов, метода getSize() и get(int index)
- class BaseList, реализует методы интерфейса CustomList.
- class ImmutableList, наследует класс BaseList. Переопределяем метод getList(), чтобы не было возможности изменять список.
- class Mutable, наследует класс BaseList. Добавляет свои 3 метода: add(T value), set(int index, T value), remove(T value)
- В классе MainTask2, создали список строк, и передали их в наши два класса. Вывели результат.
